#include <stdio.h>

const int INF = 2147483647; // 2^31-1, максимальное значение int

int main() {
    /*
     * Ввод количества вершин
     * Ввод вершин A, B
     * Ввод графа в виде матрицы смежности, x - есть путь, вес равен x; 0 - нет пути
     * Сначала вводим вес(расстояние), далее пошлину, храним их сумму
     */
    int n, A, B;
    scanf("%d %d %d", &n, &A, &B);

    int v[n + 1][n + 1];
    int d[n + 1];
    int used[n + 1];
    int previous[n + 1];

    // массив v матрица смежности
    // массив d расстояние заполняется 'бесконечностями'
    // массив used использованности заполняется false
    // массив previous предыдущих вершин, предков, пока ничем не заполняется

    for (int i = 1; i <= n; i++) {
        used[i] = 0;
        d[i] = INF;
        for (int j = 1; j <= n; j++) {
            int weight;
            scanf("%d", &weight);
            v[i][j] = weight;
        }
    }

//    на случай, если придется вводить пошлины
//    for (int i = 1; i <= n; i++) {
//        for (int j = 1; j <= n; j++) {
//            int fee;
//            scanf("%d", &fee);
//            v[i][j] = v[i][j] + fee;
//        }
//    }

    /*
     * Решим задачу с помощью алгоритмы Дейкстры
     * В массиве d будем хранить текущее расстояние d[i] от вершины A до вершины i
     *
     * В массиве used будем хранить, помечена ли вершины i
     * used[i] == true - помечена, иначе - нет
     *
     * В массиве previous будем хранить вершины, с которую пришли в вершину i
     * previous[i] - номер предыдущей вершины
     */

    // путь до A равен 0, т.к. мы начинаем с этой вершины
    d[A] = 0;
    for (int i = 1; i <= n; i++) {
        // выбираем вершину, до которой минимальное расстояние, при этом она не должна быть помечена
        int cur = -1;
        for (int j = 1; j <= n; j++) {
            if (used[j]==0 && (cur == -1 || d[j] < d[cur]))
                cur = j;
        }
        // Если выбралась вершина, до которой расстояние бесконечность, то нет смысла дальше искать
        if (d[cur] == INF)
            break;
        used[cur] = 1;
        // Обновляю расстояния до вершин, если они больше
        for (int j = 1; j <= n; j++) {
            if (cur != j && v[cur][j] != 0) {
                if (v[cur][j] + d[cur] < d[j]) {
                    d[j] = v[cur][j] + d[cur];
                    previous[j] = cur;
                }
            }
        }
    }

    /*
     * Вывожу ответ
     * Восстанавливаю путь, это легко сделать т.к. мы хранили для каждой вершины его предка
     * т.е. то, откуда к ней пришли
     */
    if (d[B] != INF) {
        printf("Длина наименьшего пути: %d\nПуть:\n", d[B]);
        int vershina = B;
        int path[n], len = 0;
        // Восстанавливаю с конца
        path[len] = B;
        len++;
        while (vershina != A) {
            path[len] = previous[vershina];
            len++;
            vershina = previous[vershina];
        }
        // вывожу сам путь
        for (int i = len - 1; i >= 0; i--)
            printf("%d ", path[i]);
        printf("\n");
    } else
        printf("Из A в B не существует пути\n");
    return 0;
}